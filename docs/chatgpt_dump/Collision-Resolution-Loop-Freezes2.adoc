= Why Recomputing Distance Still Freezes the Loop
Even when recomputing `distance` inside the loop, it can still freeze. This
happens when:

* The distance between ball centers becomes **zero or extremely close to zero**.
* The overlap becomes **very tiny** but never fully resolves because floating-
  point error prevents the condition from becoming false.
* The collision logic attempts to normalize a zero-length vector.

Below is the real reason and the correct fix.

== The Real Crash Scenario: Distance == 0
If two balls overlap **perfectly**, meaning:

----
b1->px == b2->px
b1->py == b2->py
----

Then:

----
dx = 0
dy = 0
distance = sqrt(0 + 0) = 0
----

Normalizing `(dx, dy)` becomes:

----
nx = dx / distance  --> division by zero
----

This produces `NaN`, and once NaNs enter your coordinates, your loop **never
terminates**, because every test becomes nonsense.

== Why This Happens
Your simulation allows balls to be pushed so close together (or initialized too
close) that they fully overlap before you start resolving.

Your while-loop approach *cannot* recover when distance reaches 0.

== The Fix: Replace the Loop With One Guaranteed Separation Step
Physics engines never use repeated loops; they use one mathematically correct
position correction.

Here is the correct safe displacement code:

[source,c]
----
float dx = b1->px - b2->px;
float dy = b1->py - b2->py;
float d2 = dx*dx + dy*dy;

// If centers are identical, push them apart arbitrarily
if (d2 == 0.0f) {
    dx = 1.0f;
    dy = 0.0f;
    d2 = 1.0f;
}

float distance = sqrtf(d2);
float overlap  = (b1->radius + b2->radius) - distance;

if (overlap > 0.0f) {
    float nx = dx / distance;
    float ny = dy / distance;

    float half = overlap * 0.5f;

    b1->px += nx * half;
    b1->py += ny * half;

    b2->px -= nx * half;
    b2->py -= ny * half;
}
----

== Why This Works
* **No loop**, so it canâ€™t freeze.
* Handles the `distance == 0` case safely.
* Fully resolves the overlap mathematically.
* Guaranteed to stop balls from colliding in a single step.
* `collision_count` will now drop to zero.

== Summary
Recomputing distance didn't fix the freeze because the loop becomes invalid
whenever the distance is zero or extremely tiny.  
The correct solution is to completely remove the loop and use one safe,
mathematically correct separation step.

== Want the Full Fixed Version?
If you want, I can rewrite your entire collision detection and resolution block
into clean, safe, minimal C code.

